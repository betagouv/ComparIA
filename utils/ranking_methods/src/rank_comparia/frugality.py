# SPDX-FileCopyrightText: 2025 Pôle d'Expertise de la Régulation Numérique <contact@peren.gouv.fr>
#
# SPDX-License-Identifier: MIT

from typing import Literal, Optional

import polars as pl


def get_model_params(conversations: pl.DataFrame) -> pl.DataFrame:
    """
    Select infos about number of parameters of models

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of parameters per model
    """
    return (
        pl.concat(
            [
                conversations.select(model_name=pl.col("model_a_name"), n_param=pl.col("model_a_active_params")),
                conversations.select(model_name=pl.col("model_b_name"), n_param=pl.col("model_b_active_params")),
            ]
        )
        .drop_nulls()
        .unique(subset="model_name", keep="first")
    )


def get_models_output_tokens(conversations: pl.DataFrame) -> pl.DataFrame:
    """
    Calculates all output tokens generated by a model

    Args:
        conversations (pl.DataFrame) : Conversations data.

    Returns:
        pl.DataFrame with number of output tokens generated by model
    """
    return (
        pl.concat(
            [
                conversations.select(
                    model_name=pl.col("model_a"), total_output_tokens=pl.col("total_conv_a_output_tokens")
                ),
                conversations.select(
                    model_name=pl.col("model_b"), total_output_tokens=pl.col("total_conv_b_output_tokens")
                ),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )


def get_n_match(data: pl.DataFrame) -> pl.DataFrame:
    """
    Build a DataFrame to map the number of matches played by models

    Args :
        data : polars DataFrame with matches to calculate consumption

    Returns:
        polars DataFrame with 2 columns (model_name, number of matches played)
    """

    comparia_model_a = data.group_by(["model_a"]).len(name="n_match").with_columns(model_name="model_a").drop("model_a")
    comparia_model_b = data.group_by(["model_b"]).len(name="n_match").with_columns(model_name="model_b").drop("model_b")
    return pl.concat([comparia_model_a, comparia_model_b]).group_by("model_name").sum().sort("model_name")


def calculate_frugality_score(conversations: pl.DataFrame, n_match: Optional[pl.DataFrame]) -> pl.DataFrame:
    """
    Calculate a frugality score by model from conversations data.

    Args:
        conversations (pl.DataFrame): Conversations data.
        n_match (pl.DataFrame): Data with the number of matches by model.
        mean (bool): If True, compute mean energy consumption per conversation.

    Returns:
        pl.DataFrame: DataFrame with frugality scores.
    """

    frugal_score = (
        pl.concat(
            [
                conversations.select(
                    total_output_tokens=pl.col("total_conv_a_output_tokens"),
                    model_name=pl.col("model_a"),
                    conso_all_conv=pl.col("total_conv_a_kwh"),
                ),
                conversations.select(
                    total_output_tokens=pl.col("total_conv_b_output_tokens"),
                    model_name=pl.col("model_b"),
                    conso_all_conv=pl.col("total_conv_b_kwh"),
                ),
            ]
        )
        .group_by("model_name")
        .sum()
        .sort(by="model_name")
        .drop_nulls()
    )

    if n_match is not None:
        frugal_score = frugal_score.join(n_match, on="model_name")
        frugal_score = frugal_score.with_columns(
            mean_conso_per_match=pl.col("conso_all_conv") / pl.col("n_match"),
        )

    frugal_score = frugal_score.with_columns(
        mean_conso_per_token=pl.col("conso_all_conv") / pl.col("total_output_tokens"),
    ).drop_nans()

    return frugal_score


def get_normalized_log_cost(frugal_score: pl.DataFrame, mean: Literal["match", "token"]) -> pl.DataFrame:
    log_frugality = frugal_score.with_columns(log_cost=pl.col(f"mean_conso_per_{mean}").log(base=10))
    median_score = log_frugality.median().item(0, "log_cost")
    return log_frugality.select(model_name=pl.col("model_name"), cost=pl.col("log_cost") - pl.lit(median_score))
